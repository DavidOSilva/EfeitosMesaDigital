
#include <stdio.h>
#include"ezdsp5502.h"
#include"ezdsp5502_mcbsp.h"
#include "csl_dma.h"
#include "csl_mcbsp.h"
#include "tistdtypes.h"


//---------Glob constants---------
#define N 512

//---------Global data definition---------

/* Define transmit and receive buffers */
#pragma DATA_SECTION(transmition,"dmaTest")
#pragma DATA_ALIGN(transmition, 8)
Int16 transmition[N];

#pragma DATA_SECTION(reception,"dmaTest")
#pragma DATA_ALIGN(reception, 8);
Int16 reception[N];


Int16 counter = 0;
Int16 isActive = 0;
Uint16 xmtEventId, rcvEventId;
extern void VECSTART(void);
extern void dataMove(Int16 *, Int16 *);
Uint16 old_intm;

/* Protoype for interrupt functions */
interrupt void dmaXmtIsr(void);
interrupt void dmaRcvIsr(void);


DMA_Handle dmaHandleTx, dmaHandleRx;  // Handles para os canais de DMA de Tx e Rx

// Configuração do DMA para Transmissão (Tx)
DMA_Config dmaTxConfig = {
    DMA_DMACSDP_RMK(
        DMA_DMACSDP_DSTBEN_NOBURST,    // Sem burst de destino
        DMA_DMACSDP_DSTPACK_OFF,       // Sem empacotamento de destino
        DMA_DMACSDP_DST_PERIPH,        // Destino é um periférico (MCBSP)
        DMA_DMACSDP_SRCBEN_NOBURST,    // Sem burst de origem
        DMA_DMACSDP_SRCPACK_OFF,       // Sem empacotamento de origem
        DMA_DMACSDP_SRC_DARAMPORT0,        // Origem é a memória
        DMA_DMACSDP_DATATYPE_16BIT     // Tipo de dado: 16 bits
    ),
    DMA_DMACCR_RMK(
        DMA_DMACCR_DSTAMODE_CONST,   // Incremento de endereço de destino
        DMA_DMACCR_SRCAMODE_POSTINC,     // Endereço de origem constante
        DMA_DMACCR_ENDPROG_OFF,        // Bit de fim de programação
        DMA_DMACCR_WP_DEFAULT,         // Sem proteção de escrita
        DMA_DMACCR_REPEAT_ALWAYS,     // Sem repetição automática
        DMA_DMACCR_AUTOINIT_ON,        // Auto inicialização ligada
        DMA_DMACCR_EN_STOP,            // Desabilitado inicialmente
        DMA_DMACCR_PRIO_HI,            // Alta prioridade
        DMA_DMACCR_FS_DISABLE,         // Sincronização por elemento
        DMA_DMACCR_SYNC_XEVT1          // Sincronizar com o evento de transmissão (XEVT)
    ),
    DMA_DMACICR_RMK(
        DMA_DMACICR_AERRIE_OFF,        // Sem interrupção por erro de acesso
        DMA_DMACICR_BLOCKIE_OFF,       // Sem interrupção de bloco completo
        DMA_DMACICR_LASTIE_OFF,        // Sem interrupção de último quadro
        DMA_DMACICR_FRAMEIE_OFF,       // Sem interrupção de quadro completo
        DMA_DMACICR_FIRSTHALFIE_OFF,   // Sem interrupção de primeira metade
        DMA_DMACICR_DROPIE_OFF,        // Sem interrupção por evento descartado
        DMA_DMACICR_TIMEOUTIE_OFF      // Sem interrupção por tempo esgotado
    ),
    (DMA_AdrPtr)&transmition,         // Endereço de origem (memória de áudio)
    0,                                 // Endereço superior da origem
    (DMA_AdrPtr)(MCBSP_ADDR(DXR11)),   // Endereço de destino (registrador DXR)
    0,                                 // Endereço superior do destino
    N,                                 // Número de elementos por quadro
    1,                                 // Número de quadros
    0,                                 // Índice de quadro da origem
    0,                                 // Índice de elemento da origem
    0,                                 // Índice de quadro do destino
    0                                  // Índice de elemento do destino
};

// Configuração do DMA para Recepção (Rx)
DMA_Config dmaRxConfig = {
    DMA_DMACSDP_RMK(
        DMA_DMACSDP_DSTBEN_NOBURST,    // Sem burst de destino
        DMA_DMACSDP_DSTPACK_OFF,       // Sem empacotamento de destino
        DMA_DMACSDP_DST_DARAMPORT0,        // Destino é a memória
        DMA_DMACSDP_SRCBEN_NOBURST,    // Sem burst de origem
        DMA_DMACSDP_SRCPACK_OFF,       // Sem empacotamento de origem
        DMA_DMACSDP_SRC_PERIPH,        // Origem é um periférico (MCBSP)
        DMA_DMACSDP_DATATYPE_16BIT     // Tipo de dado: 16 bits
    ),
    DMA_DMACCR_RMK(
        DMA_DMACCR_DSTAMODE_POSTINC,   // Incremento de endereço de destino
        DMA_DMACCR_SRCAMODE_CONST,     // Endereço de origem constante
        DMA_DMACCR_ENDPROG_OFF,        // Bit de fim de programação
        DMA_DMACCR_WP_DEFAULT,         // Sem proteção de escrita
        DMA_DMACCR_REPEAT_ALWAYS,     // Sem repetição automática
        DMA_DMACCR_AUTOINIT_ON,        // Auto inicialização ligada
        DMA_DMACCR_EN_STOP,            // Desabilitado inicialmente
        DMA_DMACCR_PRIO_HI,            // Alta prioridade
        DMA_DMACCR_FS_DISABLE,         // Sincronização por elemento
        DMA_DMACCR_SYNC_REVT1             // Sincronizar com o evento de recepção (REVT)
    ),
    DMA_DMACICR_RMK(
        DMA_DMACICR_AERRIE_OFF,        // Sem interrupção por erro de acesso
        DMA_DMACICR_BLOCKIE_OFF,       // Sem interrupção de bloco completo
        DMA_DMACICR_LASTIE_OFF,        // Sem interrupção de último quadro
        DMA_DMACICR_FRAMEIE_ON,       // Sem interrupção de quadro completo
        DMA_DMACICR_FIRSTHALFIE_OFF,   // Sem interrupção de primeira metade
        DMA_DMACICR_DROPIE_OFF,        // Sem interrupção por evento descartado
        DMA_DMACICR_TIMEOUTIE_OFF      // Sem interrupção por tempo esgotado
    ),
    (DMA_AdrPtr)(MCBSP_ADDR(DRR11)),   // Endereço de origem (registrador DRR)
    0,                                 // Endereço superior da origem
    (DMA_AdrPtr)&reception,    // Endereço de destino (memória de áudio)
    0,                                 // Endereço superior do destino
    1,                                // Número de elementos por quadro
    N,                                 // Número de quadros
    0,                                 // Índice de quadro da origem
    0,                                 // Índice de elemento da origem
    0,                                 // Índice de quadro do destino
    0                                  // Índice de elemento do destino
};

DMA_Handle dmaReception, dmaTransmition;
volatile Uint16 transferComplete = FALSE;

interrupt void dmaXmtIsr(void) {

}

interrupt void dmaRcvIsr(void) {

    IRQ_disable(rcvEventId);       // Desabilita o evento de interrupção da recepção.
   // Int16 i;
    dataMove(reception,transmition);

    IRQ_enable(rcvEventId);
}


void configAudioDma (void)
{
    CSL_init();

    int i = 0;
    for (i = 0; i <= N; i++) {
           transmition[i] =  0;
           reception[i] = 0;
       }

    IRQ_setVecs((Uint32)(&VECSTART));


    dmaTxConfig.dmacssal = (DMA_AdrPtr)(((Uint32)&transmition) << 1); //origem informação armazenada
    dmaTxConfig.dmacdsal = (DMA_AdrPtr)(((Uint32)MCBSP_ADDR(DXR11)) << 1); // enviado para saida mcbsp ouvir(destino)


    dmaRxConfig.dmacssal = (DMA_AdrPtr)(((Uint32)MCBSP_ADDR(DRR11)) << 1); // (origem)
    dmaRxConfig.dmacdsal = (DMA_AdrPtr)(((Uint32)&reception) << 1); // (destino)


    dmaTransmition = DMA_open(DMA_CHA2, DMA_OPEN_RESET);  // Open DMA Channel 0
    DMA_config(dmaTransmition, &dmaTxConfig);   // Configure Channel

    dmaReception = DMA_open(DMA_CHA1, DMA_OPEN_RESET);  // Open DMA Channel 1
    DMA_config(dmaReception, &dmaRxConfig);   // Configure Channel

    /* Get interrupt event associated with DMA receive and transmit */
    xmtEventId = DMA_getEventId(dmaTransmition);
    rcvEventId = DMA_getEventId(dmaReception);

    /* Temporarily disable interrupts and clear any pending */
    /* interrupts for MCBSP transmit */
    old_intm = IRQ_globalDisable();

    /* Clear any pending interrupts for DMA channels */
    IRQ_clear(xmtEventId);
    IRQ_clear(rcvEventId);

    /* Enable DMA interrupt in IER register */
    IRQ_enable(xmtEventId);
    IRQ_enable(rcvEventId);

    /* Place DMA interrupt service addresses at associate vector */
    IRQ_plug(xmtEventId,&dmaXmtIsr);
    IRQ_plug(rcvEventId,&dmaRcvIsr);


    IRQ_globalEnable();

}

void startAudioDma (void)
{

    if(!isActive){
        DMA_start(dmaReception); // Begin Transfer
        DMA_start(dmaTransmition); // Begin Transfer
        EZDSP5502_MCBSP_init( );
        isActive = 1;
    }


}

void stopAudioDma (void)
{
    DMA_stop(dmaTransmition);  // Stop Transfer
    DMA_stop(dmaReception);  // Stop Transfer
    isActive = 0;

}
